%! TEX root = ../main.tex
\documentclass[main]{subfiles}

\begin{document}
\chapter{実験2：ビット変換方法による予測精度比較}
    \section{目的}
    前章で，Walsh関数の予測精度を確認し，MNK問題において高い予測精度を持つことを確認した．
    この章から，運行スケジュールのSUMOによるシミュレートをWalsh関数により予測する．
    ただし，そのまま運行スケジュールをWalsh関数に入力することはできない．
    運行スケジュールは整数値であるが，Walsh関数は入力にビット値しか取らないためである．
    よって，なんらかの手法で運行スケジュールをビット値に変換する必要がある．
    変換方法によって，遺伝子の中身や長さが変わるため，それによって予測精度にも影響を与えると考えられる．
    \section{実験方法}
    \ref{senkoukekka}節にてバス利用率4.5\%の時の100世代分のHVを掲示した．
    この先行研究では1世代に20個の運行スケジュールが存在する．
    よって，この実験には2000件のデータがあるがこれを学習データに用いる．
    1800件をランダムに選び学習データに，残りの200データをテストデータにする．
    後に紹介する5つの手法によって運行スケジュールをビット値に変換し，Order2のWalsh関数に学習させる．
    評価関数は，総移動時間と乗車率があるため，2つのWalsh関数を用意する．
    テストデータの運行スケジュールも同じ手法でビット値に変換し，学習済みのWalsh関数を用いてテストデータの評価値を予測する．
    実際の正しいテストデータの評価値と比べ，Walsh関数の予測精度を見る．
    予測精度を測る評価指標には決定係数とMAEを用いる．
    \section{変換手法}
    検証する5つの手法について述べる．
    それぞれの手法について，その内容，この手法で10をビットに変換するとどのようなビット列になるか，
    10路線の運行スケジュールをビットに変換したときの合計ビット長，
    この手法を選ぶメリット，デメリットをまとめる．
        \subsection{手法1：np.unpackbits}
        \begin{itemize}
            \item 内容
            
                numpyに実装されているビット変換関数を用いる．
            \item 10の時のビット列
                
                00001010
            \item 合計ビット長
            
                80
            \item メリット
            
                実装が容易．
            \item デメリット
                
                必ず長さが8になるように0埋めされるため，無駄な0が増える．
            
        \end{itemize}
        \subsection{手法2：2進数変換}
        \begin{itemize}
            \item 内容
            
                2進数変換する．
            \item 10の時のビット列
                
                001010
            \item 合計ビット長
            
                60
            \item メリット
            
                変換方法が直感的．
            \item デメリット
                
                特になし．
            
        \end{itemize}
        \subsection{手法3：5で割り2進数変換}
        \begin{itemize}
            \item 内容
            
                運行スケジュールは5分単位で立てられているため，運行スケジュールは全て5で割り切れる．
                それぞれの値を5で割ってから2進数変換する．
            \item 10の時のビット列
                
                0010
            \item 合計ビット長
            
                40
            \item メリット
            
                合計ビット長が短くなる．
            \item デメリット
                
                5で割る前の情報は失われる．
            
        \end{itemize}
        \subsection{手法4：値のインデックスのみ1}
        \begin{itemize}
            \item 内容
            
                0を12個並べ，値のインデックスのみ1にする．
            \item 10の時のビット列
                
                010000000000
            \item 合計ビット長
            
                120
            \item メリット
            
                運行スケジュールの情報を直接表現することが出来る．
            \item デメリット
                
                合計ビット長が長くなる．
            
        \end{itemize}
        \subsection{手法5：5，10$\dots$60の約数または倍数なら1}
        \begin{itemize}
            \item 内容
            
                5，10，15，20$\dots$60の約数または倍数なら1を，そうでないなら0にする．
            \item 10の時のビット列
                
                010101010101
            \item 合計ビット長
            
                120
            \item メリット
            
                シミュレーション環境では複数の路線バスを同時に動かしている．
                そのため，同じ時間に長野駅を発着する路線バスが多いと渋滞が発生しやすくなるなど，
                シミュレーション結果に相互に影響を与えている可能性がある．
                よって，複数路線の公倍数，公約数の関係を表現することにより予測精度が高められる可能性がある．
            \item デメリット
                
                合計ビット長が長くなる．

                表現方法が直感的でない．
            
        \end{itemize}
    \section{結果}
    総移動時間を目的変数にした場合の結果を表\ref{bit_1}に，乗車率を目的変数にした場合の結果を表\ref{bit_2}に示す．
    \begin{table}[h]
        \centering
        \caption{総移動時間を目的変数にした場合の予測精度}
        \begin{tabular}{c|cccc}
           & 手法内容 & 合計ビット長 & 決定係数 & MAE \\ \hline
          手法1 & np.unpackbits & 80 & 0.8998 & 133507 \\
          手法2 & 2進数変換 & 60 & 0.9097 & 120039 \\
          手法3 & 5で割り2進数変換 & 40 & 0.9536 & 88364 \\
          手法4 & 値のインデックスのみ1 & 120 & 0.8291 & 209133 \\
          手法5 & 5，10$\dots$60の約数または倍数なら1 & 120 & 0.8615 & 192688 \\
        \end{tabular}
        \label{bit_1}
    \end{table}
    \begin{table}[h]
        \centering
        \caption{乗車率を目的変数にした場合の予測精度}
        \begin{tabular}{c|cccc}
           & 手法内容 & 合計ビット長 & 決定係数 & MAE \\ \hline
          手法1 & np.unpackbits & 80 & 0.8656 & 0.0160 \\
          手法2 & 2進数変換 & 60 & 0.9970 & 0.0008 \\
          手法3 & 5で割り2進数変換 & 40 & 0.9819 & 0.0048 \\
          手法4 & 値のインデックスのみ1 & 120 & 0.9763 & 0.0057 \\
          手法5 & 5，10$\dots$60の約数または倍数なら1 & 120 & 0.9739 & 0.0075 \\
        \end{tabular}
        \label{bit_2}
    \end{table}
    総移動時間を目的変数にした場合の予測精度は決定係数，MAEともに手法3が最も精度が高かった．
    乗車率を目的変数にした場合の予測精度は決定係数，MAEともに手法2が最も精度が高かった．
    \section{考察}
    総移動時間，乗車率ともに決定係数が最も良い手法と最も悪い手法では0.1ほど差があった．
    適切に変換手法を選択しないと予測精度に大きな差が生まれることが分かる．
    総移動時間で最も良い手法は手法3，乗車率で最も良い手法は手法2であった．
    手法は異なるが，2進数変換する点は同じである．
    同じ2進数変換する手法1よりどちらも性能が良かったのは，無駄な0埋めがされておらずビット長が短くなっているからだと考えられる．
    


\end{document}